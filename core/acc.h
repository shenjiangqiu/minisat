#ifndef ACC_H
#define ACC_H
#include <math.h>
#include <algorithm>
#include <signal.h>
#include <unistd.h>
#include "event_queue.h"
#include "event.h"
#include <memory>
class process_unit
{
public:
    bool is_ready()
    {
        return !m_busy;
    }
    int ready_time()
    {
        return m_ready_time;
    }
    void dispatch(int current_time)
    {
        m_busy = true;
        m_ready_time = current_time + process_time;
    }

private:
    const int process_time;
    bool m_busy;
    int m_ready_time;
};

template <typename T>
class ACC
{
public:
    ACC() = default;
    ACC(int watcher_proc_size,
        int watcher_proc_num,
        int clause_proc_size,
        int clause_proc_num) : w_size(watcher_proc_size),
                               w_num(watcher_proc_num),
                               c_hash_size(clause_proc_size),
                               c_num(clause_proc_num),
                               m_using_watcher_unit(0),
                               m_using_clause_unit(0),
                               m_ready(false) {}
    void print_on()
    {
        print_log = true;
    }
    void print_off()
    {
        print_log = false;
    }
    bool ready() const
    {
        return m_ready;
    }
    void set_ready()
    {
        m_ready = true;
    }
    void clear()
    {
        m_ready = false;
        value_queue.clear();
        time_records.clear();
    }

    int start_sim()
    {
        //initialize the event queue;
        std::queue<std::pair<int, std::shared_ptr<T>>> clause_waiting_queue;
        auto value = value_queue.top();
        auto size = value->get_watcher_size();
        int process_size = 0;
        std::queue<std::pair<int, std::shared_ptr<T>>> waiting_queue;
        waiting_queue.push(std::make_pair(0, value));
        int i = 0;
        while (!waiting_queue.empty() && m_using_watcher_unit < w_num)
        {
            int start = waiting_queue.top().first;
            int total = waiting_queue.top().second.get_watcher_size();
            if (total - start > w_size)
            {
                auto evalue = EventValue<T>(EventType::ReadWatcherList, start, w_size, value, HardwareType::watcherListUnit, 0);
                auto event = Event<T>(evalue, i, miss_latency + i);

                i++;
                waiting_queue.top().first += w_size;
                m_event_queue.push(event);
            }
            else
            {
                auto evalue = EventValue<T>(EventType::ReadWatcherList, start, total - start, value, HardwareType::watcherListUnit, 0);
                auto event = Event<T>(evalue, i, miss_latency + i);
                i++;
                //waiting_queue.top().first += (total - start);
                m_event_queue.push(event);
                waiting_queue.pop(); //finished
                break;
            }
            m_using_watcher_unit++;
        }

        //second process the event queue,
        int last_cycle = 0;
        while (!m_event_queue.empty())
        {
            auto end_time = m_event_queue.get_next_time();
            auto event_value = m_event_queue.get_next_event();
            auto value = event_value.value;
            m_event_queue.pop();
            last_cycle = end_time;
            switch (event_value.type)
            {
            case EventType::ReadWatcherList:
                auto evalue = event_value;
                evalue.type = EventType::ProcessWatcherList;
                auto event = Event<T>(evalue, end_time, end_time + watcher_process_latency);
                i++;
                //waiting_queue.top().first += (total - start);
                m_event_queue.push(event);
                break;
            case EventType::ProcessWatcherList:
                //finished process watcher_list, start to generate new clause access event
                //fist try to send clause reading request
                auto modifiend_list = value->get_modified();
                for (auto item : modifiend_list)
                {
                    if (item.first >= event_value.index && item.first < event_value.index + event_value.size)
                    { // this clause access is generated by this event
                        clause_waiting_queue.push(std::make_pair(item.first, value));
                    }
                }
                while (!clause_waiting_queue.empty() && m_using_clause_unit < c_num)
                {
                    auto clause_wating = clause_waiting_queue.top();

                    auto evalue = event_value;
                    evalue.type = EventType::ProcessClause;
                    evalue.index = clause_waiting.first;
                    evalue.value = clause_waiting.second;
                    evalue.size = 1;
                    evalue.htype = HardwareType::ClauseUnit;
                    evalue.HardwareId = 0;
                    auto event = Event<T>(evalue, end_time, end_time + clause_process_latency);
                    m_event_queue.push_back(event);
                    clause_waiting_queue.pop();
                }

                //first to find any watcher_list_to process
                m_using_watcher_unit--;
                if (!waiting_queue.empty())
                {
                    int start = waiting_queue.top().first;
                    int total = waiting_queue.top().second.get_watcher_size();
                    if (total - start > w_size)
                    {
                        auto evalue = EventValue<T>(EventType::ReadWatcherList, start, w_size, value, HardwareType::watcherListUnit, 0);
                        auto event = Event<T>(evalue, i, miss_latency + i);

                        i++;
                        waiting_queue.top().first += w_size;
                        m_event_queue.push(event);
                    }
                    else
                    {
                        auto evalue = EventValue<T>(EventType::ReadWatcherList, start, total - start, value, HardwareType::watcherListUnit, 0);
                        auto event = Event<T>(evalue, i, miss_latency + i);
                        i++;
                        //waiting_queue.top().first += (total - start);
                        m_event_queue.push(event);
                        waiting_queue.pop(); //finished
                        break;
                    }
                    m_using_watcher_unit++;
                }

                break;
            case EventType::FinishAndSendClause:
                break;
            case EventType::ProcessClause:
                break;
            }
        }
    }
    void push_to_trail(std::shared_ptr<T> value)
    {
        value_queue.push_back(value);
    }
    int get_trail_size() const
    {
        return value_queue.size();
    }

    bool have_watcher_unit_ready() const { return m_using_watcher_unit < w_num; }
    bool have_clause_unit_ready() const { return m_using_watcher_unit < c_num; }
    void value_push(std::shared_ptr<T> value) { value_queue.push_back(value); }
    int get_max_level() { return (*std::prev(value_queue.cend()))->get_level(); }
    void push_time_records(std::shared_ptr<Time_record> time) { time_records.push_back(time); }

private:
    int w_size;
    int w_num;
    int c_num;
    int c_hash_size;
    bool m_ready;
    std::vector<std::shared_ptr<T>> value_queue;
    std::vector<std::shared_ptr<Time_record>> time_records;
    int miss_latency;
    int watcher_process_latency;
    int clause_process_latency;
    int m_using_watcher_unit;
    int m_using_clause_unit;
    bool print_log;
    EventQueue<Event<T>> m_event_queue;
};

template <typename T>
std::shared_ptr<ACC<T>> create_acc()
{
    return std::make_shared<ACC<T>>();
}

template <typename V>
class unit
{
public:
    void push_task(task<V> &task, int time)
    {
        task.start = time;
        task.end = time + task.is_first ? cache_line_hit_latency : cache_line_miss_latency;
        next_run_time = task.end < next_run_time ? task.end : next_run_time;

        task_queue.push(task);
    }

    int get_next_run_time() { return next_run_time; }
    int get_remaining() { return remaining; }
    int get_working() { return working; }

private:
    int next_run_time;
    int total_size;
    int remaining;
    int working;
    int cache_line_hit_latency;
    int cache_line_miss_latency;
};
template <typename T>
class watcher_list_process_unit
{

public:
    void run(int time)
    {
        for (auto &&unit : m_units)
        {
            if (unit.need_run(time))
            {
                unit.run(time);
            }
        }
    }
    bool need_run(int time)
    {
        return next_run_time <= time;
    }
    void push_task(const task<T> &mtask)
    {
        mtasks.push(mtask);
    }

private:
    std::queue<std::shared_ptr<task<T>>> mtasks;
    int next_run_time;
    int total_process_size;
    int remaining_unit;
    std::vector<unit> m_units;
};

#endif