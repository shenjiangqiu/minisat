#ifndef ACC_H
#define ACC_H
#include <math.h>
#include <algorithm>
#include <signal.h>
#include <unistd.h>
#include "event_queue.h"
#include "event.h"
#include <memory>

template <typename T>
class ACC
{
public:
    ACC() = delete;
    ACC(int watcher_proc_size,
        int watcher_proc_num,
        int clause_proc_num,
        int miss_latency,
        int watcher_process_latency,
        int clause_process_latency) : w_size(watcher_proc_size),
                                      w_num(watcher_proc_num),
                                      c_num(clause_proc_num),
                                      m_ready(false),
                                      miss_latency(miss_latency),
                                      watcher_process_latency(watcher_process_latency),
                                      clause_process_latency(clause_process_latency),
                                      m_using_watcher_unit(0),
                                      m_using_clause_unit(0),
                                      m_event_queue(EventComp<T>) {}
    void print_on()
    {
        print_log = true;
    }
    void print_off()
    {
        print_log = false;
    }
    bool ready() const
    {
        return m_ready;
    }
    void set_ready()
    {
        m_ready = true;
    }
    void clear()
    {
        m_ready = false;
        value_queue.clear();
        //time_records.clear();
        m_event_queue.clear();
    }

    int start_sim()
    {
        //initialize the event queue;
        std::queue<std::pair<int, std::weak_ptr<T>>> clause_waiting_queue;
        auto value = value_queue.front();
        //auto size = value->get_watcher_size();
        //int process_size = 0;
        std::queue<std::pair<int, std::weak_ptr<T>>> waiting_queue;
        waiting_queue.push(std::make_pair(0, value));
        int i = 0;
        while (!waiting_queue.empty() && m_using_watcher_unit < w_num)
        {
            int start = waiting_queue.front().first;
            int total = waiting_queue.front().second.lock()->get_watcher_size();
            if (total - start > w_size)
            {
                auto evalue = EventValue<T>(EventType::ReadWatcherList, start, w_size, value, HardwareType::watcherListUnit, 0);
                auto event = Event<T>(evalue, i, miss_latency + i);

                i++;
                waiting_queue.front().first += w_size;
                if (print_log)
                    std::cout << event << std::endl;
                m_event_queue.push(event);
                m_using_watcher_unit++;
            }
            else
            {
                auto evalue = EventValue<T>(EventType::ReadWatcherList, start, total - start, value, HardwareType::watcherListUnit, 0);
                auto event = Event<T>(evalue, i, miss_latency + i);
                i++;
                //waiting_queue.front().first += (total - start);
                if (print_log)
                    std::cout << event << std::endl;
                m_event_queue.push(event);
                waiting_queue.pop(); //finished
                m_using_watcher_unit++;
                break;
            }
        }

        //second process the event queue,
        int last_cycle = 0;
        while (!m_event_queue.empty())
        {
            auto end_time = m_event_queue.get_next_time();
            auto event_value = m_event_queue.get_next_event();
            auto value = event_value.value;
            m_event_queue.pop();
            last_cycle = end_time;
            switch (event_value.type)
            {
            case EventType::ReadWatcherList:
            {
                auto evalue = event_value;
                evalue.type = EventType::ProcessWatcherList;
                auto event = Event<T>(evalue, end_time, end_time + watcher_process_latency);
                //waiting_queue.front().first += (total - start);
                if (print_log)
                    std::cout << event << std::endl;
                m_event_queue.push(event);
                break;
            }
            case EventType::ProcessWatcherList:
            {
                //finished process watcher_list, start to generate new clause access event
                //fist try to send clause reading request
                auto modified_list = value.lock()->get_modified();
                // only sorted map support this operation
                auto lower = modified_list.lower_bound(event_value.index);
                auto upper = modified_list.upper_bound(event_value.index + event_value.size);

                while (lower != upper)
                {                                                                   // this clause access is generated by this event
                    clause_waiting_queue.push(std::make_pair(lower->first, value)); // this mean later we will need to process "value" 's "first" watch 's clause
                    lower++;
                }
                i = 0;
                while (!clause_waiting_queue.empty() && m_using_clause_unit < c_num)
                {
                    auto clause_waiting = clause_waiting_queue.front();

                    auto evalue = event_value;
                    evalue.type = EventType::ProcessClause;
                    evalue.index = clause_waiting.first;
                    evalue.value = clause_waiting.second;
                    evalue.size = 1;
                    evalue.hType = HardwareType::ClauseUnit;
                    evalue.HardwareId = 0;
                    auto event = Event<T>(evalue, i + end_time, i + end_time + clause_process_latency);
                    i++;
                    if (print_log)
                        std::cout << event << std::endl;
                    m_event_queue.push(event);
                    clause_waiting_queue.pop();
                    m_using_clause_unit++;
                }

                //first to find any watcher_list_to process
                m_using_watcher_unit--;
                if (!waiting_queue.empty())
                {
                    int start = waiting_queue.front().first;
                    int total = waiting_queue.front().second.lock()->get_watcher_size();
                    auto &&waiting_value = waiting_queue.front().second;
                    if (total - start > w_size)
                    {
                        auto evalue = EventValue<T>(EventType::ReadWatcherList, start, w_size, waiting_value, HardwareType::watcherListUnit, 0); //fix bug, here not event value, but the value of waiting queue
                        auto event = Event<T>(evalue, end_time, miss_latency + end_time);
                        waiting_queue.front().first += w_size;
                        if (print_log)
                            std::cout << event << std::endl;
                        m_event_queue.push(event);
                        m_using_watcher_unit++;
                    }
                    else
                    {
                        auto evalue = EventValue<T>(EventType::ReadWatcherList, start, total - start, waiting_value, HardwareType::watcherListUnit, 0); //fix bug, here not event value, but the value of waiting queue
                        auto event = Event<T>(evalue, end_time, miss_latency + end_time);
                        //waiting_queue.front().first += (total - start);
                        if (print_log)
                            std::cout << event << std::endl;
                        m_event_queue.push(event);
                        waiting_queue.pop(); //finished
                        m_using_watcher_unit++;
                    }
                }

                break;
            }
            case EventType::FinishAndSendClause:
                //in this case,
                break;
            case EventType::ProcessClause:
            {
                //in this case, we need to generate new event, and let waiting queue to be processed

                //first to check if we generated new assignment or conflict
                if (value.lock()->get_generated_conf() == event_value.index)
                {
                    return end_time; //we already finished!
                }
                //check if generate new assignment
                auto iter = value.lock()->get_generated_assignments().find(event_value.index);
                if (iter != value.lock()->get_generated_assignments().end())
                {

                    auto generated_assignments = (*iter).second;
                    waiting_queue.push(std::make_pair(0, generated_assignments));
                    int i = 0;
                    while (!waiting_queue.empty() && m_using_watcher_unit < w_num)
                    {
                        int start = waiting_queue.front().first;
                        int total = waiting_queue.front().second.lock()->get_watcher_size();
                        auto waiting_value = waiting_queue.front().second;
                        if (total - start > w_size)
                        {
                            auto evalue = EventValue<T>(EventType::ReadWatcherList, start, w_size, waiting_value, HardwareType::watcherListUnit, 0);
                            auto event = Event<T>(evalue, end_time + i, end_time + miss_latency + i);

                            i++;
                            waiting_queue.front().first += w_size;
                            if (print_log)
                                std::cout << event << std::endl;
                            m_event_queue.push(event);
                        }
                        else
                        {
                            auto evalue = EventValue<T>(EventType::ReadWatcherList, start, total - start, waiting_value, HardwareType::watcherListUnit, 0);
                            auto event = Event<T>(evalue, end_time + i, end_time + miss_latency + i);
                            i++;
                            //waiting_queue.front().first += (total - start);
                            if (print_log)
                                std::cout << event << std::endl;
                            m_event_queue.push(event);
                            waiting_queue.pop(); //finished
                            break;
                        }
                        m_using_watcher_unit++;
                    }
                }

                break;
            }
            } // switch
        }
        return last_cycle;
    }
    void push_to_trail(std::shared_ptr<T> value)
    {
        value_queue.push_back(value);
    }
    int get_trail_size() const
    {
        return value_queue.size();
    }

    bool have_watcher_unit_ready() const { return m_using_watcher_unit < w_num; }
    bool have_clause_unit_ready() const { return m_using_watcher_unit < c_num; }
    void value_push(std::shared_ptr<T> value) { value_queue.push_back(value); }
    int get_max_level() { return (*std::prev(value_queue.cend()))->get_level(); }
    //void push_time_records(std::shared_ptr<Time_record> time) { time_records.push_back(time); }

private:
    int w_size;
    int w_num;
    int c_num;

    bool m_ready;
    std::vector<std::shared_ptr<T>> value_queue;
    //std::vector<std::shared_ptr<Time_record>> time_records;
    int miss_latency;
    int watcher_process_latency;
    int clause_process_latency;
    int m_using_watcher_unit;
    int m_using_clause_unit;
    bool print_log;
    EventQueue<Event<T>, decltype(EventComp<T>)> m_event_queue;
};

template <typename T>
std::shared_ptr<ACC<T>> create_acc(int watcher_proc_size,
                                   int watcher_proc_num,
                                   int clause_proc_num,
                                   int miss_latency,
                                   int watcher_process_latency,
                                   int clause_process_latency)
{
    return std::make_shared<ACC<T>>(watcher_proc_size, watcher_proc_num, clause_proc_num, miss_latency, watcher_process_latency, clause_process_latency);
}

/*template <typename V>
class unit
{
public:
    void push_task(task<V> &task, int time)
    {
        task.start = time;
        task.end = time + task.is_first ? cache_line_hit_latency : cache_line_miss_latency;
        next_run_time = task.end < next_run_time ? task.end : next_run_time;

        task_queue.push(task);
    }

    int get_next_run_time() { return next_run_time; }
    int get_remaining() { return remaining; }
    int get_working() { return working; }

private:
    int next_run_time;
    int total_size;
    int remaining;
    int working;
    int cache_line_hit_latency;
    int cache_line_miss_latency;
};
template <typename T>
class watcher_list_process_unit
{

public:
    void run(int time)
    {
        for (auto &&unit : m_units)
        {
            if (unit.need_run(time))
            {
                unit.run(time);
            }
        }
    }
    bool need_run(int time)
    {
        return next_run_time <= time;
    }
    void push_task(const task<T> &mtask)
    {
        mtasks.push(mtask);
    }

private:
    std::queue<std::shared_ptr<task<T>>> mtasks;
    int next_run_time;
    int total_process_size;
    int remaining_unit;
    std::vector<unit> m_units;
};
*/
#endif